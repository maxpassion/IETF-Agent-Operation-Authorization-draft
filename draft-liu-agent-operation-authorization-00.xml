<?xml version="1.0" encoding="utf-8"?>
<!-- 
     draft-rfcxml-general-template-standard-00
  
     This template includes examples of the most commonly used features of RFCXML with comments 
     explaining how to customise them. This template can be quickly turned into an I-D by editing 
     the examples provided. Look for [REPLACE], [REPLACE/DELETE], [CHECK] and edit accordingly.
     Note - 'DELETE' means delete the element or attribute, not just the contents.
     
     Documentation is at https://authors.ietf.org/en/templates-and-schemas
-->
<?xml-model href="rfc7991bis.rnc"?>  <!-- Required for schema validation and schema-aware editing -->
<!-- <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?> -->
<!-- This third-party XSLT can be enabled for direct transformations in XML processors, including most browsers -->


<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>


<rfc
  xmlns:xi="http://www.w3.org/2001/XInclude"
  category="std"
  docName="draft-liu-agent-operation-authorization-00"
  ipr="trust200902"
  obsoletes=""
  updates=""
  submissionType="IETF"
  xml:lang="en"
  version="3">

  <front>
    <title>Agent Operation Authorization</title>
    <seriesInfo name="Internet-Draft" value="draft-liu-agent-operation-authorization-00"/>

    <author fullname="Dapeng Liu" initials="D." surname="Liu">
      <organization>Alibaba</organization>
      <address>
        <email>max.ldp@alibaba-inc.com</email>
      </address>
    </author>

    <author fullname="Hongru Zhu" initials="H." surname="Zhu">
      <organization>Alibaba</organization>
      <address>
        <email>hongru.zhr@alibaba-inc.com</email>
      </address>
    </author>

    <date year="2025" month="December" day="18"/>
    <area>Security</area>
    <workgroup>oauth</workgroup>

    <abstract>
    <t>
      This document specifies the Agent Operation Authorization framework — a structured mechanism that enables verifiable delegation of 
      actions from human principals to autonomous AI agents with fine-grained agent operation authorization.
    </t>

    <t>
      The framework introduces two distinct phases:
    </t>

    <ul>
      <li>
        <strong>Agent Operation Authorization Request:</strong>
        A human-readable proposal of operations derived from natural language input and converted to a JSON Web Token (JWT).
      </li>
      <li>
        <strong>Agent Operation Authorization Token:</strong>
        A JSON Web Token representing confirmed authorization for a specific agent operation, enforceable at runtime by agents and verifiers. It cryptographically verifies user intent, prevents unauthorized or hallucinated actions, and ensures auditable traceability of each authorized operation.
      </li>
    </ul>

    
  </abstract>    
  </front>


  <middle>
    <section anchor="introduction" title="Introduction">
      <t>In agent-based systems, especially those involving generative capabilities, it is essential to convey not only what actions are permitted but also the original intent behind them and conditions under which an autonomous agent may act on behalf of a principal.</t>

      <t>
      This document specifies the Agent Operation Authorization framework — a mechanism that enables verifiable delegation of actions from human principals to autonomous AI agents with fine-grained agent operation authorization. The framework includes Agent Operation Authorization Proposal and Agent Operation Authorization phases.
      </t>

      <t>This specification defines a new top-level JSON Web Token (JWT) claim, agent_operation, which contains fine-grained and structured operational parameters including agent_operations, constraints, and conditions. Additionally, it supports inclusion of a user-provided prompt whose authenticity is protected via a W3C Verifiable Credential (VC).</t>
      
       <t>The AI agent captures the user’s natural-language instruction during interaction, constructs a structured agent_operation_proposal object,includes a prompt evidence subfield carrying the user's natural-language instruction in the form of a JWT-based Verifiable Credential (JWT-VC), and submits the resulting JWT to the Authorization Server (AS) via OAuth 2.0 Pushed Authorization Requests (PAR) [RFC9126].</t>

      
      <t>This design ensures that downstream verifiers can validate both the policy boundaries and the provenance of the initiating instruction, without dependency on Decentralized Identifiers (DIDs). This enables secure, auditable delegation for autonomous AI Agent.</t>

    
    <t>
      Upon successful user confirmation and authentication of the Authorization Proposal during the first phase, the Authorization Server (AS) SHALL issue 
      an Agent Operation Authorization Token. This token serves as the access token for subsequent interactions.
    </t>

    <t>
      The agent MUST present this JWT access token when accessing protected resources at the AS, using the mechanisms defined in OAuth 2.0 [RFC6749] and bearer token usage rules [RFC6750].
    </t>

    <t>
      Together, these components ensure that AI systems act only within user-approved boundaries, mitigating risks such as hallucination.
    </t>

    <t>
      It is designed for use in autonomous AI Agent system, multi-agent orchestration, and regulated domains such as finance, healthcare, and public services — particularly 
      where accountability and auditability are important.
    </t>

    <t>
      The framework supports enterprise identity providers, and zero-trust architectures.
    </t>

    
    </section>

    <section anchor="requirements" title="Requirements Language">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [RFC2119].</t>
    </section>

    <section anchor="agent-operation-claim" title="agent_operation_proposal Token Structure">

     <t>
        The PAR-JWT (Pushed Authorization Request in JWT format) is used in the first phase. Its purpose is to deliver the user's original input and the agent-proposed operational strategy to the AS, enabling the generation of a high-quality consent UI and establishing an evidentiary starting point.
    </t>

    <t>
      Its format is defined as follows:
    </t>
        <figure>
                <artwork name="" type=""><![CDATA[

                {
                    "iss": "https://client.myassistant.example",
                    "sub": "user_12345@myassistant.example",
                    "aud": "https://as.online-shop.example",
                    "exp": "2025-11-11T06:00:00Z",
                    "iat": "2025-11-10T09:58:30Z",
                    "evidence": { ... },
                    "agent_identity": { ... },
                    "agent_operation_proposal": "package agent\nallow { input.transaction.amount <= 50.0 }"
                    "context": { ... }
                }

                ]]></artwork>
        </figure>


<t>
  The <strong>evidence</strong> field is a JWT in JSON-VC (JSON Web Token-based Verifiable Credential) format, generated by the agent client and included in the agent operation proposal token.
</t>
<t>
  The <strong>agent_identity</strong> claim is a structured JSON object that describes the identity of an agent acting on behalf of a user. It MUST be issued by a trusted Agent Identity Issuer 
     and cryptographically bound to the user's identity (e.g., via OpenID Connect ID Token). It provides contextual information about the agent's identity, binding to the user identity. 
     This claim is intended to be embedded in a security token (e.g., a JWT-based identity token or a Workload Identity Token) issued by a trusted Agent Identity Issuer.

  The <tt>agent_identity</tt> claim MUST be cryptographically bound to a verified user identity to prevent impersonation. The issuer of this claim MUST authenticate both the user and the client environment
    before issuance.
</t>

<t>
  The <strong>policy_proposal</strong> field is a Rego policy string for OPA enforcement.
</t>
<t>
  The <strong>context</strong> field is a structured input format for OPA decision-making.
</t>
 
<t>
  The <strong>evidence</strong> field format is as follows:
</t>

<ul>
  <li><strong>JWT Header</strong></li>
</ul>


<figure>
  <artwork name="" type=""><![CDATA[

    {
      "alg": "RS256",
      "typ": "JWT",
      "kid": "https://client.myassistant.example/.well-known/jwks.json#key-01"
    }

  ]]></artwork>
</figure>

    <t><strong>alg</strong></t>
    <t>Uses the RS256 asymmetric signing algorithm (recommended).</t>

    <t><strong>typ</strong></t>
    <t>Explicitly set to <tt>JWT</tt> to indicate the token type.</t>

    <t><strong>kid</strong></t>
    <t>The key identifier that references the public key used for verification, enabling the recipient to locate the corresponding public key (e.g., from a JWKS endpoint).</t>


<ul>
<li><strong>JWT Payload</strong></li>
</ul>

 <figure>
  <artwork name="" type=""><![CDATA[

    {
      "jti": "pt-001",
      "iss": "https://client.myassistant.example",
      "sub": "user_12345",
      "iat": 1731664500,
      "exp": 1731668100,

      // ====== W3C VC Format ======
      "type": "VerifiableCredential",
      "credentialSubject": {
        "type": "UserInputEvidence",
        "prompt": "Buy something cheap on Nov 11 night",
        "timestamp": "2025-11-11T23:30:00Z",
        "channel": "voice",
        "deviceFingerprint": "dfp_abc123"
      },
      "issuer": "https://client.myassistant.example",
      "issuanceDate": "2025-11-11T23:30:30Z",
      "expirationDate": "2025-11-12T06:00:00Z",

      // ====== Optional Proof ======
      "proof": {
        "type": "JwtProof2020",
        "created": "2025-11-11T23:30:30Z",
        "verificationMethod": "https://client.myassistant.example/#key-01"
      }
    }

  ]]></artwork>
</figure>

<ul>
  <li><strong>Public Key Discovery Mechanism (JWKS)</strong></li>
</ul>

<t>
  The client agent publishes its public keys in JSON Web Key Set (JWKS) format at the well-known endpoint <tt>/.well-known/jwks.json</tt>. To retrieve the public keys, a relying party sends an HTTPS GET request to this endpoint.
</t>

<figure>
  <artwork><![CDATA[
GET /.well-known/jwks.json
Host: client.myassistant.example
]]></artwork>
</figure>


 <figure>
  <artwork name="" type=""><![CDATA[
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "key-01",
      "alg": "RS256",
      "n": "modulus_in_base64url...",
      "e": "AQAB"
    }
  ]
}
  ]]></artwork>
</figure>

  <ul>
  <li><strong>Signature</strong></li>
  </ul>
  <t>
  The Issuer (<tt>https://client.myassistant.example</tt>) generates the signature using its private key and the RS256 (RSA Signature with SHA-256) algorithm over the concatenated content: <tt>base64url(header) + '.' + base64url(payload)</tt>.
  </t>

  <t>Final Output as Standard JWT Tripartite String</t>
  <t>
  The resulting JWT is a URL-safe, three-part encoded string in the format:
  </t>
  <t>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6Imh0dHBzOi8vY2xpZW50Lm15YW5zd2VyLmV4YW1wbGUvLndlbGwta25vd24vandrLmpzb24ja2V5LTAxIn0.
  eyJqdGkiOiJwdC0wMDEiLCJpc3MiOiJodHRwczovL2NsaWVudC5teWFuc3dlci5leGFtcGxlIiwic3ViIjoidXNlcl8xMjM0NSIsImlhdCI6MTczMTY2NDUwMCwiZXhwIjoxNzMxNjY4MTAwLCJ0eXBlIjoiVmVyaWZpYWJsZUNyZWRlbnRpYWwiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJ0eXBlIjoiVXNlcklucHV0RXZpZGVuY2UiLCJwcm9tcHQiOiJCdXkgc29tZXRoaW5nIGNoZWFwIG9uIE5vdiAxMSBu
  .SIGNATURE</t>
  
  <ul>
  <li><strong>Verification Process:</strong></li>
  </ul>
  <t>
    (1) Decode the JWT; 
    (2) Extract the <tt>kid</tt> from the header; 
    (3) Retrieve the corresponding public key from <tt>/.well-known/jwks.json</tt>; 
    (4) Validate the cryptographic signature; 
  </t>
  
<t>
  The <strong>agent_identity</strong> field format is as follows:
</t>

<figure>
        <artwork name="agent_identity format" type=""><![CDATA[
                {
                "agent_identity": {
                    "version": "1.0",
                    "id": "urn:uuid:agent-identity-789",
                    "issuer": "https://client.myassistant.example/agent-issuer",
                    "issuedTo": "user_12345@myassistant.example",
                    "issuedFor": {
                    "platform": "personal-agent.myassistant.example",
                    "client": "mobile-app-v1.myassistant.example",
                    "clientInstance": "dfp_abc123"
                    },
                    "issuanceDate": "2025-11-10T09:58:30Z",
                    "validFrom": "2025-11-10T10:00:00Z",
                    "expires": "2025-11-11T06:00:00Z"
                    }
                }
        ]]></artwork>
</figure>

<table anchor="tab-agent_identity-fields">
  <name>Table 1: agent_identity fields</name>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
      <th>Requirement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>version</td>
      <td>string</td>
      <td>Schema version</td>
      <td>MUST be "1.0"</td>
    </tr>
    <tr>
      <td>id</td>
      <td>URI</td>
      <td>Unique identifier</td>
      <td>MUST be a UUID URI</td>
    </tr>
    <tr>
      <td>issuer</td>
      <td>URI</td>
      <td>Issuer of identity</td>
      <td>MUST be a valid URI</td>
    </tr>
    <tr>
      <td>issuedTo</td>
      <td>string</td>
      <td>Target user identity</td>
      <td>MUST be a user identifier</td>
    </tr>
    <tr>
      <td>issuedFor</td>
      <td>object</td>
      <td>Agent context</td>
      <td>MUST contain platform:the logical platform or service namespace, client:The software client identifier (e.g., mobile app ID), clientInstance:A unique fingerprint of the client instance (e.g., device+app hash).</td>
    </tr>
    <tr>
      <td>issuanceDate</td>
      <td>timestamp</td>
      <td>When identity was issued</td>
      <td>MUST conform to ISO 8601</td>
    </tr>
    <tr>
      <td>validFrom</td>
      <td>timestamp</td>
      <td>When identity becomes valid</td>
      <td>MUST conform to ISO 8601</td>
    </tr>
    <tr>
      <td>expires</td>
      <td>timestamp</td>
      <td>When identity expires</td>
      <td>MUST conform to ISO 8601</td>
    </tr>
  </tbody>
</table>

<t>
  The <tt>agent_identity</tt> claim can be embedded in a Workload Identity Token (WIT)
  as defined in <xref target="I-D.ietf-wimse-workload-creds"/>.
  This enables backend services to:
  <ol spacing="normal">
    <li<Authenticate the agent as a valid workload (via WIT signature)</li>
    <li>Authorize operations based on the agent's context and its associated user (via agent_identity)</li>
  </ol>
</t>

<t>
  The <strong>agent_operation_proposal</strong> field format is as follows:
</t>

<figure>
        <artwork name="agent_operation_proposal format" type=""><![CDATA[
            {
            "agent_operation_proposal": "package agent\nallow { input.transaction.amount <= 50.0 }"
            }
       ]]></artwork>
</figure>

<t>
  The <strong>agent_operation_proposal</strong> field should be a valid Rego policy string.
</t>

<t>
  The <strong>context</strong> field format is as follows:
</t>

<figure>
        <artwork name="context format" type=""><![CDATA[
            {
            "context": {
                "channel": "mobile-app",
                "deviceFingerprint": "dfp_abc123",
                "language": "zh-CN",
                "user": {
                "id": "user_12345@myassistant.example"
                },
                "agent": {
                "instance": "dfp_abc123",
                "platform": "personal-agent.myassistant.example",
                "client": "mobile-app-v1.myassistant.example"
                }
            }
            }
       ]]></artwork>
</figure>


<t>
  The Agent Client sends this PAR-JWT to the Authorization Server (AS) via the Pushed Authorization Request (PAR) mechanism, as defined in <xref target="RFC9126"/> (OAuth 2.0 Pushed Authorization Requests).
</t>

</section>



<section anchor="agent-operation-authorization-token" title="Agent Operation Authorization Token">

<t>
  Upon successful user authorization and authentication, the Authorization Server (AS) issues a <strong>Verifiable Agent Operation Credential</strong> in the form of a JWT token. 
  The purpose of this credential is to serve as a digitally signed and independently verifiable "authorization letter", which enables the Personal Agent to perform authorized operations on behalf of the user. 
  The issuer of the credential is the <tt>Authorization Server (AS)</tt>, and the intended recipient is the <tt>Personal Agent</tt> (which may be delivered via the client). 
  The credential becomes effective immediately after the user clicks "Allow" or "Consent".
</t>


<figure>
        <artwork name="" type=""><![CDATA[

{
  "iss": "https://client.myassistant.example",
  "sub": "user_12345@myassistant.example",
  "aud": "https://api.myassistant.example",
  "exp": "2025-11-11T06:00:00Z",
  "iat": "2025-11-10T09:58:30Z",
  
  // ====== Evidence JWT-VC======
  "evidence": {
    "sourcePromptCredential": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...SIGNATURE"
  },
  
  // ====== Agent Identity ======
  "agent_identity": { ... },
  
  // ====== Agent Operation Authorization ======
  "agent_operation_authorization": {
    "policy_id": "opa-policy-789"
  },
  "context": { 
    "renderedText": "Purchase items under $50 during the Dec 11 night (00:00–06:00)"
   }，
  
  // ====== auditTrail ======
  "auditTrail": {
      "originalPromptText": "Buy something cheap on Nov 11 night",
      "renderedOperationText": "Purchase items under $50 during the Dec 11 night (00:00–06:00)",
      "semanticExpansionLevel": "medium",
      "userAcknowledgeTimestamp": "2025-11-11T10:23:31Z",
      "consentInterfaceVersion": "consent-ui-v2.1"
  },

  // ====== Optional: Reference to Proposal ======
  "references": {
    "relatedProposalId": "urn:uuid:op-proposal-456"
  }
}

      ]]></artwork>
</figure>

<t>
  To support secure agent-to-agent delegation, the Agent Operation Authorization Token MAY include a <strong>delegation_chain</strong> claim.
  This claim records the sequence of prior delegations, enabling verifiers to reconstruct the full authorization lineage back to the original human principal.
</t>

<figure>
  <artwork name="" type=""><![CDATA[
  // ====== Optional: Delegation Chain (for A2A) ======
  "delegation_chain": [
    {
      "delegator_token_jti": "urn:uuid:token-abc-123",
      "delegator_agent_identity": { /* agent_identity of Agent A */ },
      "delegation_timestamp": "2025-12-18T10:15:00Z",
      "operation_summary": "Delegate inventory check for item X"
    }
  ]
  ]]></artwork>
</figure>

<t>
  The <strong>delegation_chain</strong> is an array of delegation records, ordered from most recent to earliest.
  Each record MUST be cryptographically bound to the issuing Authorization Server during token issuance (see <xref target="a2a-delegation"/>).
</t>     

     
<t>The <strong>policy_id</strong> field is a string that serves as an OPA policy reference and MUST match a registered policy in the AS</t>


    <ul>
      <li><strong>auditTrail</strong> establishes a complete, semantically traceable chain—from the user's original intent to the system's final executed action—in AI Agent scenarios. This mechanism is known as a <em>Semantic Audit Trail</em>. The specific purposes and their descriptions are outlined in the following table:</li>
    </ul>

    <table anchor="tbl-audit-trail-purposes">
      <name>Purposes and Descriptions of the Semantic Audit Trail</name>
      <thead>
        <tr>
          <th align="left">Purpose</th>
          <th align="left">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>1. Intent Provenance</td>
          <td>Records what the user originally said (e.g., "Buy something cheap on Nov 11 night") to prevent disputes such as: "I didn’t say I wanted to buy anything!"</td>
        </tr>
        <tr>
          <td>2. Action Interpretation</td>
          <td>Documents how the system interpreted and rendered the input into a concrete operation (e.g., "Purchase under $50 during 00:00–06:00"), reflecting the AI’s reasoning process.</td>
        </tr>
        <tr>
          <td>3. Semantic Transparency</td>
          <td>Shows whether semantic expansions or default values were applied (e.g., mapping "cheap" to $50, defining "night" as 00:00–06:00).</td>
        </tr>
        <tr>
          <td>4. User Confirmation Evidence</td>
          <td>Includes timestamps indicating when the user reviewed and confirmed the interpreted action, serving as proof of authorization.</td>
        </tr>
        <tr>
          <td>5. Accountability Support</td>
          <td>Enables post-hoc analysis in case of erroneous transactions: Was the issue due to ambiguous user input, system misinterpretation, or misleading UI guidance.</td>
        </tr>
      </tbody>
    </table>

  </section> 

<section anchor="user-agent-binding" numbered="true" toc="default">
  <name>User-Agent Identity Binding Model</name>

  <t>
    To ensure the integrity of the <tt>issuedTo</tt> field, the Agent Identity
    Issuer MUST verify the user's identity using a standardized authentication
    protocol such as OpenID Connect <xref target="OpenID"/>.
    A typical flow is as follows:
  </t>
  <ol spacing="normal">
    <li>The user authenticates to an Identitiy Provider and obtains an ID Token.</li>
    <li>The client presents this ID Token (or a DPoP-bound access token) to the
    Agent Identity Issuer.</li>
    <li>The Issuer validates the token signature, audience, and expiration,
    then extracts the <tt>sub</tt> claim as the value for <tt>issuedTo</tt>.</li>
    <li>The Issuer issues a new token containing the <tt>agent_identity</tt> claim,
    signed with its own key.</li>
  </ol>

  <t>
    This approach leverages existing, standardized identity infrastructure
    and ensures that the binding between user and agent is non-forgeable.
  </t>
</section>

<section anchor="wimse-interoperability" numbered="true" toc="default">
  <name>Interoperability with WIMSE Workload Identity Tokens</name>
  <t>
    The <tt>agent_identity</tt> claim can be embedded in a Workload Identity
    Token (WIT) as defined in <xref target="I-D.ietf-wimse-workload-creds"/>.
    In such a deployment:
  </t>
  <ul spacing="compact">
    <li>The WIT serves as the workload credential for the agent (authenticating
    it as a valid workload via SPIFFE-like identity or issuer trust).</li>
    <li>The <tt>agent_identity</tt> claim provides the user context required
    for operation-level authorization decisions.</li>
  </ul>

  <t>
    This combination enables a layered security model:
    <ul spacing="normal">
      <t>Layer 1: Workload authentication (via WIT signature and subject)</t>
      <t>Layer 2: User-contextual authorization (via <tt>agent_identity.issuedTo</tt> and scopes)</t>
    </ul>
    Such a model aligns with zero-trust principles and supports fine-grained
    auditability.
  </t>
</section>

<section anchor="workflow" title="Workflow">
  <section title="High-Level Flow">
  
  <figure>
          <artwork name="" type=""><![CDATA[
+--------+       +----------------+       +--------+       +------------------+
|  User  |       |   AI Agent     |       |  AS    |       | Resource Server  |
+--------+       +----------------+       +--------+       +------------------+
     |                   |                    |                    |
(1)  |      prompt       |                    |                    |
     |------------------>|                    |                    |
     |                   |                    |                    |
(2)  |                   | Parse & structure  |                    |
     |                   | operation proposal |                    |
     |                   |                    |                    |
(3)  |                   | Generate user's    |                    |
     |                   | prompt VC          |                    |
     |                   |                    |                    |
(4)  |                   | Build operation    |                    |
     |                   | proposal JWT       |                    |
     |                   |                    |                    |
(5)  |                   |                    | POST /par          |
     |                   |                    | with JWT --------->|
     |                   |                    |                    |
(6)  |                   |                    | Return request_uri |
     |                   |                    |<-------------------|
     |                   |                    |                    |
(7)  |                   | Redirect user to   |                    |
     |                   | /authorize?request_uri=...              |
     |                   |---------------------------------------->|
     |                   |                    |                    |
(8)  | Approve           |                    |                    |
     |<------------------------------------------------------------|
     |                   |                    |                    |
(9)  |                   |                    | Validate JWT       |
     |                   |                    | Extract operation  |
     |                   |                    | Issue access token |
     |                   |                    |<-------------------|
     |                   |                    |                    |
(10) |                   | Present access     |                    |
     |                   | token ------------>| Resource API       |
     |                   |                    |------------------->|
     |                   |                    | Enforce operation  |
     |                   |                    | Execute or deny    |
     |                   |                    |<-------------------|
     |                   |                    | Response           |
     |<------------------------------------------------------------|
          ]]></artwork>
        </figure>
      </section>

<section title="Detailed Process Flow">
        <figure>
          <artwork name="" type=""><![CDATA[
(1) User says: "Buy something cheap on Nov 11 night"
     |
     v
(2) AI Agent parses intent → builds operation proposal object
     |
     v
(3) AS generate the original prompt VC using local private key (bound to issuerKey)
     |
     v
(4) Agent creates evidence section : { "evidence": { "sourcePromptCredential": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...SIGNATURE"} }
     |
     v
(5) Agent creates JWT with operation proposal claim, signs with JWS
     |
     v
(6) Agent sends JWT to AS via PAR: POST /par { "request": "<jwt>" }
     |
     v
(7) AS validates JWS, extracts evidence field and validate
     |
     v
(8) AS issues request_uri to agent
     |
     v
(9) Agent redirects user to /authorize?request_uri=...
     |
     v
(10) User reviews the original prompt and the agent_operation_authorization and approves
     |
     v

(11) AS register the policy and issues Agent Operation Authorization Token as access token which includes the policy_id
     |
     v
(12) Agent uses token to access Resource Server
     |
     v
(13) AS verifies evidence VC 
     |
     v
(14) RS enforces OPA policy
     |
     v
(15) Action executed or denied


          ]]></artwork>
        </figure>

      </section>
    </section>

<section anchor="a2a-delegation" title="Agent-to-Agent Delegation">
  <t>
    In multi-agent systems, a primary agent (Agent A) may need to delegate part of its authorized operation to a secondary agent (Agent B).
    This specification enables such delegation while preserving the chain of trust back to the original human principal.
  </t>

  <section title="Delegation Request via PAR">
    <t>
      When Agent A initiates delegation, it constructs a new Pushed Authorization Request (PAR) JWT that includes:
    </t>
    <ul spacing="normal">
      <li>The original <tt>evidence.sourcePromptCredential</tt> from its own authorization token (unchanged);</li>
      <li>A new <tt>agent_operation_proposal</tt> representing the sub-operation for Agent B;</li>
      <li>Its own <tt>agent_identity</tt> as the delegator;</li>
      <li>An optional <tt>delegation_chain</tt> copied from its current token.</li>
    </ul>
    <t>
      This PAR-JWT is submitted to the same Authorization Server (AS) that issued the original token.
    </t>
  </section>

  <section title="Authorization Server Validation">
    <t>
      Upon receiving an A2A PAR request, the AS MUST perform the following checks:
    </t>
    <ol spacing="normal">
      <li>
        Validate the signature and integrity of the included <tt>sourcePromptCredential</tt>.
      </li>
      <li>
        Retrieve the policy associated with the original token (via internal state or by parsing the proposal if first-time delegation).
      </li>
      <li>
        Verify that the new <tt>agent_operation_proposal</tt> is <em>contained within</em> the original authorization scope.
        This is typically implemented by evaluating whether the new Rego policy implies the original one (e.g., using OPA partial evaluation or pre-registered policy templates).
      </li>
      <li>
        Confirm that the requesting agent (Agent A) is authorized to delegate (e.g., via a <tt>delegation_allowed</tt> flag in its original token or client registration).
      </li>
    </ol>
    <t>
       If all checks pass and the delegation does not require additional user consent (e.g., because the sub-operation is provably within the original authorization scope and delegation was explicitly permitted),
       the AS issues a new Agent Operation Authorization Token for Agent B without requiring further user interaction.
       The resulting token includes a signed <tt>delegation_chain</tt> entry that references Agent A’s token (<tt>jti</tt>) and identity,
       preserving end-to-end auditability back to the original human principal.
  </t>
  </section>

  <section title="Trust Chain Preservation">
    <t>
      The resulting token for Agent B contains:
    </t>
    <ul spacing="normal">
      <li>The same <tt>evidence.sourcePromptCredential</tt> as the original human-initiated request;</li>
      <li>A new <tt>policy_id</tt> corresponding to the sub-operation;</li>
      <li>An extended <tt>delegation_chain</tt> with Agent A’s delegation record.</li>
    </ul>
    <t>
      Resource Servers can thus verify that every action—no matter how many hops—ultimately traces back to a human-confirmed intent,
      and that no agent has exceeded its granted authority.
    </t>
  </section>
</section>

    <section anchor="security" title="Security Considerations">
      <t>The combination of JWS and VC provides dual-layer integrity: JWS protects the token, VC protects the prompt.</t>
      <t>Authorization Servers MUST validate the VC proof using the referenced issuerKey and associated public key material before accepting the request.</t>
      <t>Public keys referenced by issuerKey MUST be obtained through secure, trusted mechanisms (e.g., pre-registration, PKI).</t>
      <t>Expression evaluation (e.g., CEL) MUST occur in sandboxed environments.</t>
      <t>The use of PAR prevents leakage of sensitive operation data in URLs.</t>

     <t>
       For Agent-to-Agent delegation, the Authorization Server acts as the central policy enforcer and trust anchor.
       It MUST NOT issue delegation tokens unless it can cryptographically verify the provenance of the original user intent
       and confirm that the proposed sub-operation is within the bounds of the original authorization.
     </t>
     <t>
       Implementers SHOULD limit delegation depth (e.g., max 2 hops) to prevent infinite delegation chains.
       The <tt>delegation_chain</tt> MUST be constructed and signed by the AS—not self-reported by agents—to prevent forgery.
     </t>
    </section>

<section anchor="iana" title="IANA Considerations">
  <section title="JWT Claim Registration">
    <t>
      This document requests IANA to register the following two claims in the "JSON Web Token Claims" registry, 
      following the procedure defined in RFC 8126.
    </t>


    <!-- Claim 1: agent_identity -->
    <dl>
      <dt>Claim Name:</dt>
      <dd>agent_identity</dd>
      <dt>Claim Description:</dt>
      <dd>
        A structured claim that conveys the identity and issuance metadata of an autonomous agent acting on behalf of a user. 
        It includes a unique identifier, issuer, target user, deployment context, and validity timestamps, enabling secure binding of agent operations to a verified identity.
      </dd>
      <dt>Change Controller:</dt>
      <dd>IETF</dd>
      <dt>Specification Document:</dt>
      <dd> This document requests registration of the <tt>agent_identity</tt> claim in the IANA "JSON Web Token Claims" registry <xref target="RFC7519"/>.</dd>
    </dl>

    <!-- Claim 2: agent_operation_proposal -->
    <dl>
      <dt>Claim Name:</dt>
      <dd>agent_operation_proposal</dd>
      <dt>Claim Description:</dt>
      <dd>
        A Rego policy string proposed by an agent for authorization evaluation. This claim is used in the initial authorization 
        request to convey a policy that, upon validation and registration by the Authorization Server, will be referenced via a policy_id in subsequent access tokens.
      </dd>
      <dt>Change Controller:</dt>
      <dd>IETF</dd>
      <dt>Specification Document:</dt>
      <dd>This document, Section X.Y ("Agent Operation Proposal")</dd>
    </dl>

    <!-- Claim 3: agent_operation_authorization -->
    <dl>
      <dt>Claim Name:</dt>
      <dd>agent_operation_authorization</dd>
      <dt>Claim Description:</dt>
      <dd>
       A structured claim that conveys authorization metadata for agent-performed operations, including a reference to a registered policy via the policy_id field. 
       This claim is included in access tokens issued after successful policy validation and registration by the Authorization Server.
      </dd>
      <dt>Change Controller:</dt>
      <dd>IETF</dd>
      <dt>Specification Document:</dt>
      <dd>This document, Section X.Z ("Agent Operation Authorization")</dd>
    </dl>

    <!-- Claim 4: context -->
    <dl>
      <dt>Claim Name:</dt>
      <dd>context</dd>
      <dt>Claim Description:</dt>
      <dd>
       A structured claim providing contextual information for policy evaluation, including user and agent identity attributes, device characteristics, 
       channel, and locale. This claim serves as the input data for Open Policy Agent (OPA) enforcement decisions.
      </dd>
      <dt>Change Controller:</dt>
      <dd>IETF</dd>
      <dt>Specification Document:</dt>
      <dd>This document, Section X.Z ("context")</dd>
    </dl>

     <!-- Claim 5: delegation_chain -->
     <dl>
       <dt>Claim Name:</dt>
       <dd>delegation_chain</dd>
       <dt>Claim Description:</dt>
       <dd>
         An optional array of delegation records that trace the sequence of agent-to-agent authorizations
         leading to the current token. Each record includes the delegator's token identifier, identity,
         timestamp, and operation summary. This claim enables end-to-end auditability and trust chain validation.
       </dd>
       <dt>Change Controller:</dt>
       <dd>IETF</dd>
       <dt>Specification Document:</dt>
       <dd>This document, Section <xref target="a2a-delegation" format="counter"/>.</dd>
     </dl>

  </section>

    <section title="JSON Schema (Informative)" anchor="json-schema">
    <t>
        While not required for interoperability, implementers may find it useful to
        validate claim structures using JSON Schema. Informative schemas for the
        claims defined in this document may be developed and published separately.
        Such schemas are not normative and do not require IANA registration.
    </t>
    </section>

</section>


</middle>

      
<back>
    <references>
      <name>References</name>
        <references>
          <name>Normative References</name>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9126.xml"/>
      </references>
    </references>
    <reference anchor="I-D.ietf-wimse-workload-creds">
              <front>
                <title>Workload Identity Credentials</title>
                <author>
                  <organization>IETF WIMSE Working Group</organization>
                </author>
                <date year="2024" month="October"/>
              </front>
              <seriesInfo name="Internet-Draft" value="draft-ietf-wimse-workload-creds"/>
     </reference>
                
     <reference anchor="OpenID" target="https://openid.net/specs/openid-connect-core-1_0.html">
              <front>
                <title>OpenID Connect Core 1.0</title>
                <author>
                  <organization>OpenID Foundation</organization>
                </author>
                <date year="2014" month="November"/>
              </front>
     </reference>
      
  
    <section title="Acknowledgments" numbered="false">
      <t>The author thanks contributors from the IETF community for their valuable feedback on agent authorization semantics.</t>
    </section>
  </back>

</rfc>
